{"version":3,"sources":["images/marker.svg","utils/constants.ts","providers/httpClient.ts","providers/process.ts","components/graph/sidenavEdge.tsx","components/graph/graph.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["IP_API_URL","SKY_NODEVIZ_URL","process","httpClient","axios","create","headers","preprocessGraph","a","nodes","edges","Error","finalNodes","pkeyMap","Map","ips","Object","keys","getips","apiresult","key","undefined","node","id","title","x","latitude","y","longitude","public_keys","forEach","p_key","set","push","finalEdges","map","edge","handleTooltipText","sourcePKey","targetPKey","t_id","t_type","type","t_label","label","source","get","target","requests","chunk","rec","i","length","req","data","JSON","stringify","post","result","ipres","ip_address","arr","size","output","Array","Math","ceil","seekIndex","outputIndex","slice","fetchUptimePoll","then","r","SidenavEdge","className","Graph","markerIcon","Icon","iconUrl","marker","iconSize","useState","isOpen","setIsOpen","toggleModal","isInitial","setIsInitial","selectedEdge","setSelectedEdge","loading","errMsg","selected","preprocessedResult","graphState","setGraphState","fetchUpdate","res","e","filterEdges","index","array","j","useEffect","catch","interval","setInterval","clearInterval","southWest","LatLng","northEast","handleEdges","filter","el","idx","MapContainer","zoom","center","scrollWheelZoom","bounds","LatLngBounds","maxBounds","TileLayer","url","n","Marker","position","eventHandlers","click","_","selectedEdges","console","log","icon","Popup","pubkeys","k","onClick","onRequestClose","overlayClassName","preventScroll","toast","error","autoClose","closeOnClick","pauseOnHover","draggable","info","dismiss","dotenv","config","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.588f2c65.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/marker.8a6e5ca6.svg\";","// export const IP_PRO_TOKEN = assertEnv(process.env.PRO_API_TOKEN, 'PRO_API_TOKEN')\n// export const IP_API_URL = \"http://ip-api.com/batch?fields=192\";\n// export const PRO_API_URL = `http://pro.ip-api.com/batch?key=${IP_PRO_TOKEN}`;\nexport const IP_API_URL = \"https://ip.skycoin.com/batch\";\nexport const SKY_NODEVIZ_URL = process.env.REACT_APP_SKY_NODEVIZ_URL || \"http://localhost:9081/map\";\n","import axios from \"axios\";\n\nexport const httpClient = axios.create({\n    headers: {\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Credentials\": \"true\",\n        \"Content-Type\": \"application/json\",\n    },\n});\n","import {\n    EdgeData,\n    GeoIPRequest,\n    GeoIPResponse,\n    IPResult,\n    NodeData,\n    PollResult,\n    PreProcessedGraphResult,\n} from \"../models/models\";\nimport {IP_API_URL, SKY_NODEVIZ_URL} from \"../utils/constants\";\nimport {httpClient} from \"./httpClient\";\n\nexport const preprocessGraph = async ({nodes, edges}: PollResult): Promise<PreProcessedGraphResult> => {\n    if (nodes === null || edges === null) {\n        throw new Error(\"nodes and edges are null\");\n    }\n\n    let finalNodes: NodeData[] = [];\n    let pkeyMap = new Map<string, string>();\n    let ips = Object.keys(nodes!);\n    let apiresult: Record<string, IPResult> = await getips(ips);\n    // Process Node and create a Map (Public Key -> IP)\n    for (const key in apiresult) {\n        if (nodes![key] === undefined) continue\n        let node = {\n            id: key,\n            title: key,\n            x: apiresult[key].latitude,\n            y: apiresult[key].longitude,\n            public_keys: nodes![key].public_keys,\n        };\n        nodes![key].public_keys.forEach(p_key => {\n            pkeyMap.set(p_key, key);\n        });\n        finalNodes.push(node);\n    }\n    // Process Edges\n    let finalEdges: EdgeData[] = edges!.map(edge => {\n        let edgeData: EdgeData = {\n            handleTooltipText: `Source : ${edge.edges[0]} \\n Target : ${edge.edges[1]}`,\n            sourcePKey: edge.edges[0],\n            targetPKey: edge.edges[1],\n            t_id: edge.t_id,\n            t_type: edge.type,\n            t_label: edge.label,\n            source: pkeyMap.get(edge.edges[0])!,\n            target: pkeyMap.get(edge.edges[1])!,\n        };\n        return edgeData;\n    });\n    return {\n        nodes: finalNodes,\n        edges: finalEdges,\n        pkeyMap: pkeyMap,\n    };\n};\n\nasync function getips(ips: string[]): Promise<Record<string, IPResult>> {\n    let requests = chunk(ips, 300);\n    let rec: Record<string, IPResult> = {};\n\n    // chunk it\n    for (let i = 0; i < requests.length; i++) {\n        let req: GeoIPRequest = {\n            ips: requests[i],\n        };\n        const data = JSON.stringify(req);\n        const res = await httpClient.post(IP_API_URL, data);\n        res.data.result.forEach((ipres: IPResult) => {\n            rec[ipres.ip_address] = ipres;\n        });\n    }\n\n    return rec;\n}\n\nfunction chunk(arr: string[], size: number): string[][] {\n    const length = arr.length;\n    const output: string[][] = new Array(Math.ceil(length / size));\n    let seekIndex = 0, outputIndex = 0;\n    while (seekIndex < length) {\n        output[outputIndex++] = arr.slice(seekIndex, seekIndex += size);\n    }\n    return output;\n}\n\nexport async function fetchUptimePoll(): Promise<PollResult> {\n    let result: PollResult = {};\n    try {\n        await httpClient.get(SKY_NODEVIZ_URL).then((r) => {\n            result = r.data;\n        });\n        return result;\n    } catch (e) {\n        throw e;\n    }\n}\n","import React from \"react\";\nimport { EdgeData } from \"../../models/models\";\n\nexport interface SidenavEdgeProps {\n    edge: EdgeData;\n}\n\nconst SidenavEdge: React.FC<SidenavEdgeProps> = ({ edge }) => {\n    return (\n        <div id=\"node-info\">\n            <h2>Transport</h2>\n            <p className=\"tt\">{edge.t_id}</p>\n            <strong>Source IP:</strong>\n            {edge.source}\n            <br />\n            <strong>Source IP:</strong>\n            {edge.source}\n            <br />\n            <strong>Target IP:</strong>\n            {edge.target}\n            <br />\n            <strong>Transport Type::</strong>\n            {edge.t_type}\n            <br />\n            <strong>Transport Label:</strong>\n            {edge.t_label}\n            <br />\n            <strong>Source Visor:</strong>\n            <p>{edge.sourcePKey}</p>\n            <strong>Target Visor:</strong>\n            <p>{edge.targetPKey}</p>\n            <br />\n        </div>\n    );\n};\n\nexport default SidenavEdge;\n","import { Icon, LatLng, LatLngBounds } from \"leaflet\";\nimport React, { Fragment, useEffect, useState } from \"react\";\nimport { MapContainer, Marker, Popup, TileLayer } from \"react-leaflet\";\nimport Modal from \"react-modal\";\nimport { toast } from \"react-toastify\";\nimport marker from \"../../images/marker.svg\";\nimport { EdgeData, NodeData, PreProcessedGraphResult, SelectedData } from \"../../models/models\";\nimport { fetchUptimePoll, preprocessGraph } from \"../../providers/process\";\nimport SidenavEdge from \"./sidenavEdge\";\n\nexport interface GraphProps {\n}\n\ninterface GraphState {\n    loading: boolean;\n    selected: SelectedData;\n    preprocessedResult: PreProcessedGraphResult;\n    errMsg: string;\n}\n\nconst Graph: React.FC<GraphProps> = () => {\n    const markerIcon = new Icon({\n        iconUrl: marker,\n        iconSize: [25, 25],\n    });\n    const [isOpen, setIsOpen] = useState(false);\n\n    function toggleModal() {\n        setIsOpen(!isOpen);\n    }\n\n    const [isInitial, setIsInitial] = useState<boolean>(false);\n    const [selectedEdge, setSelectedEdge] = useState<EdgeData | undefined>(undefined);\n    const [graphState, setGraphState] = useState<GraphState>({\n        loading: false,\n        errMsg: \"\",\n        selected: {\n            node: undefined,\n            edges: undefined,\n        },\n        preprocessedResult: {\n            nodes: [],\n            edges: [],\n            pkeyMap: new Map<string, string>(),\n        },\n    });\n\n    const TIMEOUT_MS = 60000 * 5;\n\n    useEffect(() => {\n        fetchUpdate().catch((e) => setGraphState({ ...graphState, errMsg: e, loading: false }));\n        setIsInitial(true);\n    }, []);\n\n    useEffect(() => {\n        const interval = setInterval(() => {\n            fetchUpdate().catch((e) => setGraphState({ ...graphState, errMsg: e, loading: false }));\n        }, TIMEOUT_MS);\n\n        return () => clearInterval(interval);\n    }, [isInitial]);\n\n    async function fetchUpdate() {\n        setGraphState({ ...graphState, loading: true });\n        try {\n            fetchUptimePoll().then((r) => {\n                preprocessGraph(r).then((res) => {\n                    setGraphState({ ...graphState, preprocessedResult: res });\n                });\n            });\n        } catch (e: any) {\n            setGraphState({ ...graphState, errMsg: e, loading: false });\n        }\n    }\n\n    function filterEdges(edge: EdgeData, index: number, array: EdgeData[]): boolean {\n        let keys = graphState.selected.node?.public_keys;\n        if (keys === undefined) return false;\n        for (let j = 0; j < keys.length; j++) {\n            if (edge.sourcePKey === keys![j] || edge.targetPKey === keys[j]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getEdges(selected: NodeData, edges: EdgeData[]): EdgeData[] | undefined {\n        return edges.filter(filterEdges);\n    }\n\n    const southWest = new LatLng(-90, -180);\n    const northEast = new LatLng(90, 180);\n\n    const handleEdges = (key: string) => {\n        if (graphState.selected.edges === undefined) return;\n        let edge = graphState.selected.edges!.filter((el, idx, arr) => el.sourcePKey === key || el.targetPKey === key);\n        if (edge.length > 0) {\n            setSelectedEdge(edge[0]);\n            return (e: any) => toggleModal();\n        } else return (e: any) => {};\n    };\n\n    const pubKeyRender = (pubkeys: string[]) => {\n        return pubkeys.map((k: string, i: number) => <li onClick={handleEdges(k)}>{k}</li>);\n    };\n\n    return (\n        <Fragment>\n            <MapContainer\n                zoom={3}\n                center={[45.00, 90.00]}\n                scrollWheelZoom={false}\n                bounds={new LatLngBounds(southWest, northEast)}\n                maxBounds={new LatLngBounds(southWest, northEast)}\n            >\n                <TileLayer url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" />\n                {graphState.preprocessedResult.nodes.map((n) => (\n                    <Marker\n                        key={n.id}\n                        position={[n.x!, n.y!]}\n                        eventHandlers={{\n                            click: (_: any) => {\n                                let selectedEdges = getEdges(n, graphState.preprocessedResult.edges);\n                                console.log(\"EDGES: \", selectedEdges);\n                                setGraphState({\n                                    ...graphState,\n                                    selected: {\n                                        node: n,\n                                        edges: selectedEdges,\n                                    },\n                                });\n                            },\n                        }}\n                        icon={markerIcon}\n                    >\n                        <Popup>\n                            <div className=\"map-popup\">\n                                <h3>Visors</h3>\n                                <ul>\n                                    {n.public_keys !== undefined && n.public_keys.length > 0\n                                        ? pubKeyRender(n.public_keys)\n                                        : <p>Empty</p>}\n                                </ul>\n                                {selectedEdge !== undefined\n                                    ? (\n                                        <Modal\n                                            isOpen={isOpen}\n                                            onRequestClose={toggleModal}\n                                            className=\"edge-modal\"\n                                            overlayClassName=\"edge-overlay\"\n                                            preventScroll={false}\n                                        >\n                                            <SidenavEdge edge={selectedEdge} />\n                                        </Modal>\n                                    )\n                                    : <div />}\n                            </div>\n                            {/*<SidenavNode node={graphState.selected.node!} />*/}\n                        </Popup>\n                    </Marker>\n                ))}\n            </MapContainer>\n            {graphState.errMsg !== \"\"\n                ? toast({\n                    error: graphState.errMsg,\n                    position: \"top-right\",\n                    autoClose: 5000,\n                    closeOnClick: true,\n                    pauseOnHover: true,\n                    draggable: true,\n                })\n                : <div />}\n            {graphState.loading\n                ? toast({\n                    info: \"loading data\",\n                    position: \"top-right\",\n                    dismiss: graphState.loading,\n                })\n                : <div />}\n        </Fragment>\n    );\n};\n\nexport default Graph;\n","import dotenv from \"dotenv\";\nimport React from \"react\";\nimport \"./App.css\";\nimport Graph from \"./components/graph/graph\";\n\ndotenv.config();\n\ninterface AppProps {}\n\nconst App: React.FunctionComponent<AppProps> = () => {\n    return (\n        <div>\n            <Graph />\n        </div>\n    );\n};\n\nexport default App;\n","import { ReportHandler } from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n    if (onPerfEntry && onPerfEntry instanceof Function) {\n        import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n            getCLS(onPerfEntry);\n            getFID(onPerfEntry);\n            getFCP(onPerfEntry);\n            getLCP(onPerfEntry);\n            getTTFB(onPerfEntry);\n        });\n    }\n};\n\nexport default reportWebVitals;\n","import \"leaflet/dist/leaflet.css\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"./index.css\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById(\"root\"),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}