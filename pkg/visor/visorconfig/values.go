// Package visorconfig defines variables and constants for different operating systems
package visorconfig

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"os/user"
	"path/filepath"
	"strings"

	"github.com/bitfield/script"
	"github.com/skycoin/dmsg/pkg/disc"
	"github.com/skycoin/dmsg/pkg/dmsg"

	"github.com/skycoin/skywire-utilities/pkg/buildinfo"
	"github.com/skycoin/skywire-utilities/pkg/cipher"
	"github.com/skycoin/skywire-utilities/pkg/cmdutil"
	"github.com/skycoin/skywire-utilities/pkg/logging"
	"github.com/skycoin/skywire/pkg/skyenv"
)

var (
	//OS detection at runtime
	OS = skyenv.OS
	// SkywirePath is the path to the installation folder for the linux packages.
	SkywirePath = skyenv.SkywirePath
	// ConfigJSON is the config name generated by the skywire-autocofig script in the linux packages
	ConfigJSON = skyenv.ConfigJSON

	// config file constants

	// ConfigName is the default config name. Updated by setting config file path.
	ConfigName = skyenv.ConfigName
	// DMSGHTTPName is the default dmsghttp config name
	DMSGHTTPName = skyenv.DMSGHTTPName
	// SERVICESName is the default services config name - should be the same contents as conf.skywire.skycoin.com or hardcoded fallback in skywire-utilities/pkg/skyenv
	SERVICESName = skyenv.SERVICESName

	// Dmsg port constants.
	// TODO(evanlinjin): Define these properly. These are currently random.

	DmsgCtrlPort           = skyenv.DmsgCtrlPort           // DmsgCtrlPort Listening port for dmsgctrl protocol (similar to TCP Echo Protocol).
	DmsgSetupPort          = skyenv.DmsgSetupPort          // DmsgSetupPort Listening port of a setup node.
	DmsgHypervisorPort     = skyenv.DmsgHypervisorPort     // DmsgHypervisorPort Listening port of a hypervisor for incoming RPC visor connections over dmsg.
	DmsgTransportSetupPort = skyenv.DmsgTransportSetupPort // DmsgTransportSetupPort Listening port for transport setup RPC over dmsg.
	DmsgHTTPPort           = dmsg.DefaultDmsgHTTPPort      // DmsgHTTPPort Listening port for dmsghttp logserver.
	DmsgAwaitSetupPort     = skyenv.DmsgAwaitSetupPort     // DmsgAwaitSetupPort Listening port of a visor for setup operations.

	// Transport port constants.

	TransportPort     = skyenv.TransportPort     // TransportPort Listening port of a visor for incoming transports.
	PublicAutoconnect = skyenv.PublicAutoconnect // PublicAutoconnect ...

	// Dmsgpty constants.

	DmsgPtyPort   = skyenv.DmsgPtyPort   // DmsgPtyPort ...
	DmsgPtyCLINet = skyenv.DmsgPtyCLINet // DmsgPtyCLINet ...

	// Skywire-TCP constants.

	STCPAddr = skyenv.STCPAddr // STCPAddr ...

	// Default skywire app constants.

	SkychatName = skyenv.SkychatName // SkychatName ...
	SkychatPort = skyenv.SkychatPort // SkychatPort ...
	SkychatAddr = skyenv.SkychatAddr // SkychatAddr ...

	PingTestName = skyenv.PingTestName // PingTestName ...
	PingTestPort = skyenv.PingTestPort // PingTestPort ...

	SkysocksName = skyenv.SkysocksName // SkysocksName ...
	SkysocksPort = skyenv.SkysocksPort // SkysocksPort ...

	SkysocksClientName = skyenv.SkysocksClientName // SkysocksClientName ...
	SkysocksClientPort = skyenv.SkysocksClientPort // SkysocksClientPort ...
	SkysocksClientAddr = skyenv.SkysocksClientAddr // SkysocksClientAddr ...

	VPNServerName = skyenv.VPNServerName // VPNServerName ...
	VPNServerPort = skyenv.VPNServerPort // VPNServerPort ...

	VPNClientName = skyenv.VPNClientName // VPNClientName ...

	// TODO(darkrengarius): this one's not needed for the app to run but lack of it causes errors

	VPNClientPort = skyenv.VPNClientPort // VPNClientPort ...

	ExampleServerName       = skyenv.ExampleServerName       // ExampleServerName ...
	ExampleServerPort       = skyenv.ExampleServerPort       // ExampleServerPort ...
	ExampleClientName       = skyenv.ExampleClientName       // ExampleClientName ...
	ExampleClientPort       = skyenv.ExampleClientPort       // ExampleClientPort ...
	SkyForwardingServerName = skyenv.SkyForwardingServerName // SkyForwardingServerName ...
	SkyForwardingServerPort = skyenv.SkyForwardingServerPort // SkyForwardingServerPort ...
	SkyPingName             = skyenv.SkyPingName             // SkyPingName ...
	SkyPingPort             = skyenv.SkyPingPort             // SkyPingPort ...

	// RPC constants.

	RPCAddr             = skyenv.RPCAddr             // RPCAddr ...
	RPCTimeout          = skyenv.RPCTimeout          // RPCTimeout ...
	TransportRPCTimeout = skyenv.TransportRPCTimeout // TransportRPCTimeout ...
	UpdateRPCTimeout    = skyenv.UpdateRPCTimeout    // UpdateRPCTimeout ...

	// Default skywire app server and discovery constants

	AppSrvAddr                = skyenv.AppSrvAddr                // AppSrvAddr ...
	ServiceDiscUpdateInterval = skyenv.ServiceDiscUpdateInterval // ServiceDiscUpdateInterval ...
	AppBinPath                = skyenv.AppBinPath                // AppBinPath ...
	LogLevel                  = skyenv.LogLevel                  // LogLevel ...

	// Routing constants

	TpLogStore = skyenv.TpLogStore // TpLogStore ...
	Custom     = skyenv.Custom     // Custom ...

	// Local constants

	LocalPath = skyenv.LocalPath // LocalPath ...

	// Default hypervisor constants

	HypervisorDB      = skyenv.HypervisorDB      // HypervisorDB ...
	EnableAuth        = skyenv.EnableAuth        // EnableAuth ...
	PackageEnableAuth = skyenv.PackageEnableAuth // PackageEnableAuth ...
	EnableTLS         = skyenv.EnableTLS         // EnableTLS ...
	TLSKey            = skyenv.TLSKey            // TLSKey ...
	TLSCert           = skyenv.TLSCert           // TLSCert ...

	// IPCShutdownMessageType sends IPC shutdown message type
	IPCShutdownMessageType = skyenv.IPCShutdownMessageType

	// IsPublic advertises the visor in the service discovery
	IsPublic = skyenv.IsPublic

	// NodeInfo is the name of the survey file
	NodeInfo = skyenv.NodeInfo

	// RewardFile is the name of the file containing skycoin reward address
	RewardFile = skyenv.RewardFile
)

// SkywireConfig returns the full path to the package config
func SkywireConfig() string {
	return SkywirePath + "/" + ConfigJSON
}

// PkgConfig struct contains paths specific to the linux packages
type PkgConfig struct {
	LauncherBinPath string `json:"launcher"`
	LocalPath       string `json:"local_path"`
	Hypervisor      `json:"hypervisor"`
	//		TLSCertFile string `json:"tls_cert_file"`
	//		TLSKeyFile  string `json:"tls_key_file"`
}

// LauncherBinPath struct contains the BinPath specific to the installation
type LauncherBinPath struct {
	BinPath string `json:"bin_path"`
}

// Hypervisor struct contains Hypervisor paths specific to the linux packages
type Hypervisor struct {
	DbPath     string `json:"db_path"`
	EnableAuth bool   `json:"enable_auth"`
}

// DmsgPtyWhiteList gets dmsgpty whitelist path for installed Skywire.
func DmsgPtyWhiteList() string {
	return filepath.Join(SkywirePath, "dmsgpty", "whitelist.json")
}

// MustPK unmarshals string PK to cipher.PubKey. It panics if unmarshaling fails.
func MustPK(pk string) cipher.PubKey {
	var sPK cipher.PubKey
	if err := sPK.UnmarshalText([]byte(pk)); err != nil {
		fmt.Printf("invalid public key: %s", pk)
		panic(err)
	}

	return sPK
}

// MustPKs unmarshals comma separated list of string PKs to []cipher.PubKey. It panics if unmarshaling fails.
func MustPKs(pks string) []cipher.PubKey {
	var sPKs cipher.PubKeys
	if err := sPKs.Set(pks); err != nil {
		fmt.Printf("invalid public key or keys: %s", pks)
		panic(err)
	}
	return []cipher.PubKey(sPKs)
}

// Version gets the version of the installation for the config
func Version() string {
	u := buildinfo.Version()
	v := u
	if u == "unknown" {
		//check for .git folder for versioning
		if _, err := os.Stat(".git"); err == nil {
			//attempt to version from git sources
			if _, err = exec.LookPath("git"); err == nil {
				if v, err = script.Exec(`git describe`).String(); err == nil {
					v = strings.ReplaceAll(v, "\n", "")
					v = strings.Split(v, "-")[0]
				}
			}
		}
	}
	return v
}

// HomePath gets the current user's home folder
func HomePath() string {
	dir, _ := os.UserHomeDir() //nolint
	return dir
}

// Config returns either UserConfig or PackageConfig based on permissions
func Config() skyenv.PkgConfig {
	if IsRoot() {
		return skyenv.PackageConfig()
	}
	return UserConfig()
}

// IsRoot checks for root permissions
func IsRoot() bool {
	userLvl, _ := user.Current() //nolint
	return userLvl.Username == "root"
}

// FetchIP fetches the ip address by dmsg servers
func FetchIP(dmsgDisc string) (string, error) {
	log := logging.MustGetLogger("ip_skycoin_fetch_dmsg")
	ctx, cancel := cmdutil.SignalContext(context.Background(), nil)
	defer cancel()

	pk, sk := cipher.GenerateKeyPair()

	dmsgC, closeDmsg, err := startDmsg(ctx, log, pk, sk, dmsgDisc)
	if err != nil {
		return "", fmt.Errorf("failed to start dmsg")
	}
	defer closeDmsg()

	ip, err := dmsgC.LookupIP(ctx, nil)
	return ip.String(), err
}

func startDmsg(ctx context.Context, log *logging.Logger, pk cipher.PubKey, sk cipher.SecKey, dmsgDisc string) (dmsgC *dmsg.Client, stop func(), err error) {
	dmsgC = dmsg.NewClient(pk, sk, disc.NewHTTP(dmsgDisc, &http.Client{}, log), &dmsg.Config{MinSessions: dmsg.DefaultMinSessions})
	go dmsgC.Serve(context.Background())

	stop = func() {
		err := dmsgC.Close()
		log.WithError(err).Debug("Disconnected from dmsg network.")
		fmt.Printf("\n")
	}
	log.WithField("public_key", pk.String()).WithField("dmsg_disc", dmsgDisc).
		Debug("Connecting to dmsg network...")

	select {
	case <-ctx.Done():
		stop()
		return nil, nil, ctx.Err()

	case <-dmsgC.Ready():
		log.Debug("Dmsg network ready.")
		return dmsgC, stop, nil
	}
}

var (
	// VisorConfigFile will contain the path to the visor's config or `stdin` to denote that the config was read from STDIN
	VisorConfigFile string
)

// PackageConfig returns the package-specific config paths
func PackageConfig() skyenv.PkgConfig {
	return skyenv.PackageConfig()
}

// UpdateCommand returns the commands which are run when the update button is clicked in the ui
func UpdateCommand() []string {
	return []string{`echo "not implemented"`}
}
