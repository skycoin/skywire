import chalk from 'chalk';
import crypto from 'crypto';
import findCacheDir from 'find-cache-dir';
import { findUpSync, pathExistsSync } from 'find-up';
import fse from 'fs-extra';
import { globbySync as glob } from 'globby';
import yaml from 'js-yaml';
import { reduce } from 'lodash-es';
import { createRequire } from 'node:module';
import { dirname, join, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { packageDirectorySync } from 'pkg-dir';
// FIXME Jest workaround: cannot properly mock `child_process` with import API
const cp = createRequire(import.meta.url)('child_process');
const { ensureDirSync, readFileSync } = fse;
const __dirname = dirname(fileURLToPath(import.meta.url));
export const pkgDir = (cwd) => packageDirectorySync({ cwd });
export const invoke = (cmd, args, cwd, silent = false, inherit = true, skipError = false) => {
    !silent && console.log(chalk.bold('invoke'), cmd, ...args);
    const stdio = inherit
        ? ['inherit', 'inherit', 'inherit']
        : [null, null, null]; // eslint-disable-line
    const result = cp.spawnSync(cmd, args, { cwd, stdio });
    if (!skipError && (result.error || result.status)) {
        throw result;
    }
    return String(result.stdout?.toString().trim());
};
const checkValue = (key, value, omitlist, picklist) => value !== 'false' &&
    !omitlist.includes(key) &&
    (picklist.length === 0 || picklist.includes(key));
const formatFlag = (key) => (key.length === 1 ? '-' : '--') + key;
// https://gist.github.com/nblackburn/875e6ff75bc8ce171c758bf75f304707
const camelToKebab = (string) => string.replace(/([\da-z]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
export const normalizeFlags = (flags) => Object.keys(flags).reduce((m, key) => {
    m[camelToKebab(key)] = flags[key];
    return m;
}, {});
export const formatFlags = (flags, ...picklist) => Object.keys(flags).reduce((memo, key) => {
    const omitlist = ['_', '--'];
    const value = flags[key];
    const flag = formatFlag(key);
    if (checkValue(key, value, omitlist, picklist)) {
        memo.push(flag);
        if (value !== true) {
            memo.push(value);
        }
    }
    return memo;
}, []);
export const mapFlags = (flags, mapping) => reduce(flags, (memo, value, key) => {
    const repl = mapping[key];
    let k = key;
    let v = value;
    if (repl) {
        if (typeof repl === 'string') {
            k = repl;
        }
        else {
            k = repl?.key ?? k;
            v = repl?.value ?? repl?.values?.[value] ?? v;
        }
    }
    memo[k] = v;
    return memo;
}, {});
export const isWindows = () => process.platform === 'win32' ||
    /^(msys|cygwin)$/.test(process.env.OSTYPE);
export const getSymlinkType = (type) => type || (isWindows() ? 'junction' : 'dir');
// https://github.com/facebook/jest/issues/2993
export const getYarn = () => (isWindows() ? 'yarn.cmd' : 'yarn');
export const getClosestBin = (cmd) => String(findUpSync((dir) => {
    const ref = resolve(dir, 'node_modules', '.bin', cmd);
    return pathExistsSync(ref) ? ref : undefined;
}, {
    cwd: String(pkgDir(__dirname)),
}));
export const getNpm = (npmPath = 'system', isWin = isWindows()) => {
    const cmd = isWin ? 'npm.cmd' : 'npm';
    if (npmPath === 'system') {
        return cmd;
    }
    if (npmPath === 'local') {
        return getClosestBin(cmd);
    }
    return npmPath;
};
export const getWorkspaces = (cwd, manifest) => {
    let packages = manifest.workspaces;
    if (packages && packages.packages) {
        packages = packages.packages;
    }
    if (!packages || packages.length === 0) {
        return [];
    }
    // Turn workspaces into list of package.json files.
    return glob(packages.map((p) => p.replace(/\/?$/, '/package.json')), {
        cwd,
        onlyFiles: true,
        absolute: true,
        gitignore: true,
    });
};
export const readJson = (path) => JSON.parse(readFileSync(path).toString('utf-8').trim());
export const ensureDir = (dir) => {
    ensureDirSync(dir);
    return dir;
};
export const getTemp = (cwd, temp) => {
    if (temp) {
        return ensureDir(resolve(temp));
    }
    const id = crypto.randomBytes(16).toString('hex');
    const cacheDir = findCacheDir({ name: 'yarn-audit-fix', cwd }) + '';
    const tempDir = join(cacheDir, id);
    return ensureDir(tempDir);
};
export const attempt = (f) => {
    try {
        return f();
    }
    catch {
        return null; // eslint-disable-line
    }
};
export const parseYaml = (contents) => {
    try {
        return yaml.load(contents);
    }
    catch (e) {
        throw new Error(`YAML required: ${e}`);
    }
};
export const formatYaml = yaml.dump;
export const getBinVersion = (bin, cwd = process.cwd()) => invoke(bin, ['--version'], cwd, true, false);
